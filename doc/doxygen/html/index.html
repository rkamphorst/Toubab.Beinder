<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Beinder: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Beinder
   </div>
   <div id="projectbrief">simple data binding</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Beinder Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>From <a href="https://en.wikipedia.org/wiki/Data_binding">Wikipedia</a>:</p>
<blockquote class="doxtable">
<p>Data binding is the process that establishes a connection between the application UI (User Interface) and Business logic. If the settings and notifications are correctly set, the data reflects changes when made. It can also mean that when the UI is changed, the underlying data will reflect that change.</p>
<p></p>
</blockquote>
<p>There are a lot of implementations of data binding, in C# and beyond. So why this library? I've written up a small <a href="#justification">justification</a> for myself below. It explains the main goals for Beinder:</p>
<ol type="1">
<li><b>Only do binding.</b></li>
<li><b>Be loosely coupled to the software that uses it.</b></li>
<li><b>Be adaptable through extension.</b></li>
<li><b>Be usable with minimal configuration.</b></li>
</ol>
<h2>TL;DR</h2>
<pre class="fragment">/* Create binder */
var binder = new Binder();

/* Establish bindings.
 * Store the bindings in this._bindings to make sure it is not garbage collected.
 * This is typically done when the view appears (*not* when it is created!)
 */
this._bindings = binder.Bind(viewModel, view);

/* Destroy bindings.
 * Typically when the view disappears.
 */
this._bindings.Dispose();
this._bindings = null;
</pre><h2>Features</h2>
<ul>
<li><a href="#pattern-agnostic">Pattern agnostic</a></li>
<li><a href="#name-based-binding">Name-based binding</a></li>
<li><a href="#recursive-binding">Recursive binding</a></li>
<li><a href="#binding-across-object-boundaries">Binding across object boundaries</a></li>
<li><a href="#binding-of-collections">Binding of collections</a> (not yet implemented)</li>
<li><a href="#value-conversion">Value conversion</a> (not yet implemented)</li>
<li><a href="#value-change-propagation">Value change propagation</a></li>
<li><a href="#dynamic-rebinding">Dynamic rebinding</a></li>
<li><a href="#adaptation-through-extension">Adaptation through extension</a></li>
</ul>
<h3>Pattern agnostic</h3>
<p>Although designed with the MVVM pattern in mind, the library does not know of views, view models or business logic. It only knows of objects that have properties, events and event handlers that need to be bound in some way.</p>
<p>This results in the view and view model sides being treated exactly the same. The binder only knows they are objects, not what function they have.</p>
<p>And although in MVVM, you typically only bind two objects, it is possible to use the binder to bind more than two. If, for some reason, you need to do this, just pass more objects to <code>Binder.Bind()</code>.</p>
<h3>Name-based binding</h3>
<p>When you bind two (or more) objects, properties with the same name get bound to each other.</p>
<ul>
<li><b>The only way to bind two properties to each other is to give them the same name.</b> There is no other (explicit) way to indicate that one property should be bound to a specific property on another object.</li>
</ul>
<ul>
<li><b>Bindings are two-way when possible.</b> If two properties are bound to each other and one of them is read-only, obviously values can only propagate from the read-only property to the write-enabled property. However, when all bound properties are read-write, values can and will propagate from any of them to any of them.</li>
</ul>
<ul>
<li><b>No per-property data conversions can be specified</b>. If a property could not be set because (for example) it has the wrong data type, this will fail silently. However, if there are 'properties of properties' (a.k.a. <em>child properties</em>) that match, those will be bound to each other instead (see <a href="#recursive-binding">Recursive binding</a>).</li>
</ul>
<p>Example: </p>
<pre class="fragment">/* ViewModelClass and ViewClass both have a string property MyProperty,
 * and they both implement INotifyPropertyChanged
 */
var view = new ViewClass { MyProperty = "aaa" };
var viewModel = new ViewModelClass { MyProperty = "bbb" };

this._bindings = binder.Bind(viewModel, view);

//  viewModel.MyProperty is now bound to view.MyProperty.
//  view.MyProperty will have the value "bbb".

view.MyProperty = "ccc";      // propagates "ccc" to viewModel.MyProperty
viewModel.MyProperty = "ddd"; // propagates "ddd" to view.MyProperty
</pre><h3>Recursive binding</h3>
<p>If values of properties that are bound have matching properties, those <em>child properties</em> will be bound as well. This can be extended to child properties of child properties, and so on.</p>
<p>Example: </p>
<pre class="fragment">/* ViewModelClass, ViewClass, ControlModelClass and ControlClass all 
 * implement interface INotifyPropertyChanged.
 */
var view = new ViewClass() { MyControl = new ControlClass { Label = "aaa" } };
var viewModel = new ViewModelClass() { MyControl = new ControlModelClass { Label = "bbb" } };

this._bindings = binder.Bind(viewModel, view);

//  viewModel.MyControl.Label is now bound to view.MyControl.Label.
//  both will have the value "bbb".

view.MyControl.Label = "ccc";      // propagates "ccc" to viewModel.MyControl.Label
viewModel.MyControl.Label = "ddd"; // propagates "ddd" to view.MyControl.Label
</pre><h3>Binding across object boundaries</h3>
<p>If a property's name is a concatenation of another property's name and the name of one of it's child properties, the former property is bound to the child property. Again, this can be extended to child properties of child properties, etc.</p>
<p>Example: </p>
<pre class="fragment">/* ViewModelClass, ViewClass, and ControlClass all implement interface 
 * INotifyPropertyChanged.
 */
var view = new ViewClass() { MyControl = new ControlClass { Label = "aaa" } };
var viewModel = new ViewModelClass() { MyControlLabel = "bbb" };

this._bindings = binder.Bind(viewModel, view);

//  viewModel.MyControlLabel is now bound to view.MyControl.Label.
//  both will have the value "bbb".

view.MyControl.Label = "ccc";      // propagates "ccc" to viewModel.MyControlLabel
viewModel.MyControlLabel = "ddd";  // propagates "ddd" to view.MyControl.Label
</pre><h3>Binding of collections</h3>
<p><b>TODO: not yet implemented</b></p>
<h3>Value conversions</h3>
<p><b>TODO: not yet implemented</b></p>
<h3>Value change propagation</h3>
<p>When <code>Binder.Bind()</code> is called, properties are bound, and then values are propagated. The values are propagated from properties on the first parameter to properties on the other parameters. Recall that in in the previous examples, the bound properties would initially be set to the value of the <code>viewModel</code>'s property: this is because <code>viewModel</code> was always the first parameter to <code>Bind()</code>.</p>
<p>After a property has been bound, and its value changes, its value can be propagated to the other properties it is bound to. However, for this to happen, an event is needed that is raised whenever the property changes. This needs to be implemented in the class/object the property comes from. There are two standard ways in order to do this:</p>
<ol type="1">
<li>Implement <code>INotifyPropertyChanged</code> on the objects you want to bind. See also <a href="Toubab.Beinder/PropertyScanners/NotifyPropertyChangedScanner.cs">NotifyPropertyChangedScanner</a>.</li>
<li>Implement an event (handler type <code>EventHandler</code>) for each property you wan to bind, with the same name, but postfixed with "Changed". Raise it whenever the property is set with a new value. See also <a href="Toubab.Beinder/PropertyScanners/ReflectionScanner.cs">ReflectionScanner</a>.</li>
</ol>
<h3>Dynamic rebinding</h3>
<p>Whenever a property's value changes, and this new value is propagated to other properties, what happens to the property's <em>child properties</em>? They get rebound.</p>
<p>Consider the following example. </p>
<pre class="fragment">/* ViewModelClass, ViewClass, ControlModelClass, ControlClass and TextControlClass all 
 * implement interface INotifyPropertyChanged.
 */
var view = new ViewClass() { MyControl = new ControlClass { Label = "aaa" } };
var viewModel = new ViewModelClass() { MyControl = new ControlModelClass { Label = "bbb", Text = "ccc" };

this._bindings = binder.Bind(viewModel, view);

//  viewModel.MyControl.Label is now bound to view.MyControl.Label.
//  Both will have the value "bbb".
//  viewModel.MyControl.Text is not bound to anything and will have value null.

view.MyControl = new TextControlClass { Text = "ddd" };

// viewModel.MyControl.Text gets *rebound* to view.MyControl.Text.
// Both will now have value "ddd".
// viewModel.MyControl.Label will still have value "bbb".
</pre><h3>Adaptation through extension</h3>
<h4>Properties: <code>ICustomProperty&lt;T&gt;</code></h4>
<h4>Mixins: <code>IMixin&lt;T&gt;</code></h4>
<h4>Namespace preference: affinity and specialization</h4>
<h4>Scanners: <code>IScanner</code></h4>
<h4>Path Parsers: <code>IPathParser</code></h4>
<h2>Justification</h2>
<p>So why roll my own binding library?</p>
<p>(Data) binding is implememented as part of many frameworks, for many languages and for many programming environments (see the mentioned wikipedia page for more examples). Examples for C# include a myriad of UI frameworks that Microsoft has made over the years (Windows Forms, WPF, ASP.NET, ...), and the last couple of years the various MVVM frameworks that have sprung up to support cross-platform app development in C# (examples are <a href="https://github.com/MvvmCross/MvvmCross">MvvmCross</a>, <a href="https://mvvmlight.codeplex.com/">MVVM Light Toolkit</a>, <a href="https://xamarin.com/forms">Xamarin Forms</a>).</p>
<p>Most existing implementations, IMHO, have the following drawbacks:</p>
<ol type="1">
<li>They are <em>part of</em> a larger framework, and cannot easily be used outside that framework. Especially MvvmCross has a splendid binding implementation; however, choosing its binding framework without pulling in the rest into your project is difficult (I did succeed, though).</li>
<li>They are complex and hard to configure. This is mostly solved by having great IDE support and great documentation. However, if you do not possess the right IDE and/or have a specific problem that is not covered by IDE or docs, or there is a small bug that needs to be solved, you need to dive into the framework's code and learn all of its intricate details.</li>
<li>They give too much freedom in the wrong places. This results in complexity where it is not needed, code that is difficult to read, and View-ViewModel bindings that are hard to track.</li>
</ol>
<p>Therefore, the goals of Beinder are to:</p>
<ol type="1">
<li><b>Only do binding.</b> ...but do it as well as any other framework, or better.</li>
<li><b>Be loosely coupled to the software that uses it.</b> The code/configuration footprint related to the use of this library should be as small as possible and in a small number of places.</li>
<li><b>Be adaptable through extension.</b> Any aspect of the library that could need adaptation, e.g. to a specific platform or toolkit, should be adaptable through extension.</li>
<li><b>Be usable with minimal configuration.</b> Have a sensible default configuration that handles almost all of the cases, and use <em>adaptation through extension</em> for the rest.</li>
</ol>
<p>However, the most important reason to make this library is... well because it's fun :-) </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 30 2016 17:05:07 for Beinder by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
